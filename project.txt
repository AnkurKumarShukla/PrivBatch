PrivBatch Coordinator - Development Plan & Demo Strategy
Development Plan (2-3 Week Timeline)
Phase 1: Foundation & Research (Days 1-3)
Environment & Learning

Set up Foundry development environment
Clone Uniswap v4 template from official repo
Complete relevant sections of Cyfrin Uniswap v4 course (hooks, singleton, PositionManager)
Study key documentation areas:

PoolManager and flash accounting mechanics
PositionManager batched operations
Hook callback system and verification patterns
OpenZeppelin Uniswap hooks library



Initial Deployment

Deploy test pool on Sepolia (ETH/USDC pair)
Test basic add/remove liquidity operations via PositionManager
Document 2-3 transaction IDs for baseline operations
Verify gas costs and transaction structure

Research & Validation

Calculate impermanent loss scenarios for poorly positioned ranges
Research MEV attack vectors (sandwich attacks, front-running on LP actions)
Document privacy leakage points (wallet tracking, position size visibility)
Establish baseline metrics for comparison


Phase 2: Smart Contract Development (Days 4-9)
CommitContract (Simple Anti-Front-Running)

Deploy commit-hash contract for intent submissions
Implement commit phase (users submit hash of their intent)
Add reveal window mechanism (time-locked)
Create verification logic (reveal matches commit)

Custom Hook Implementation

Extend OpenZeppelin hook base contract
Implement beforeModifyPosition:

Verify Merkle proof of batch inclusion
Validate EIP-712 signatures for each intent
Check batch meets minimum size/diversity rules


Implement afterAddLiquidity:

Enforce MEV-resistant rules (pool diversity, batch constraints)
Emit verification events with batch hash


Add emergency pause mechanism

Batched Liquidity Logic

Use PositionManager's modifyLiquidities for atomic operations
Encode multiple actions: remove old + add new optimized positions
Implement delta settlement via flash accounting
Test gas efficiency vs individual transactions

Security & Testing

Write Foundry tests for invalid batches (should revert)
Test valid batches with multiple intents
Fuzz test range parameters and proof failures
Implement checks-effects-interactions pattern
Test reentrancy protection

Milestone: Hook deployed with 4-6 test transaction IDs showing proof verification and batched operations

Phase 3: Offchain Agent Development (Days 10-15)
Intent Collection System

Build simple API endpoint for receiving signed intents
Implement EIP-712 signing standard for user intents
Create intent validation (check signature, nonce, deadline)
Store pending intents (database or IPFS)

Aggregation & Optimization Engine

Intent batching logic (group by pool, time window)
Oracle integration (Chainlink or Pyth for price feeds)
IL-optimal range calculator:

Center range on predicted mean price
Width based on volatility (k * historical vol)
Account for fee tier and pool characteristics


Adaptive feedback system:

Track historical IL from previous batches (onchain events)
Adjust range parameters dynamically
Simple moving average for continuous improvement



Proof Generation

Build Merkle tree from batched intents
Generate Merkle proofs for hook verification
Create batch commitment hash

Execution Layer

Web3 transaction builder (ethers.js/web3.py)
Flashbots integration for private mempool submission
Batch transaction submission via PositionManager
Randomized delay within time window (anti-MEV)
Pool splitting logic for large batches

Agent Intelligence Features

Rule-based core: Price/volatility → optimal range (deterministic)
Adaptive learning: Adjust parameters based on past performance
Optional LLM integration: Fallback range suggestions for edge cases
Decision logging to IPFS for transparency

Monitoring & Transparency

Log all decisions (console + IPFS)
Emit onchain events for every batch
Performance tracking dashboard (simple metrics)

Milestone: Agent runs end-to-end locally, submits 8-12 test transactions on Sepolia

Phase 4: Integration & Hardening (Days 16-18)
Permissionless Filler Design

Open-source agent script
Document how anyone can run as competing filler
Add filler competition logic (fastest valid batch wins)
Create simple incentive mechanism (filler fee from gas savings)

MEV Protection Enhancements

Implement full commit-reveal flow
Add decoy batch submissions (randomized)
Pool diversity enforcement in hook
Bundle submission timing randomization

Privacy Features

Batch aggregation hides individual wallet timing
Position size obfuscation through splitting
IPFS-based public verifiability without revealing pre-execution

Edge Case Handling

Fallback for solo liquidity adds (direct Uniswap app)
Batch delay timeout mechanism
Invalid proof rejection and user notification
Oracle failure handling


Phase 5: Testing & Documentation (Days 19-21)
Comprehensive Testing

Simulate price drift scenarios → rebalance batches
Test large single adds (blocked by minimum batch size)
Invalid proof submissions (should revert)
MEV attack simulations (front-running attempts)
Gas comparison: solo vs batched operations
IL comparison: optimized ranges vs random ranges

Performance Metrics

Calculate IL reduction percentage
Measure gas savings from batching
Document MEV attack prevention success rate
Track range optimization accuracy

Documentation

Architecture diagram (Mermaid: user → commit → agent → hook → pool)
Mathematical explanation of IL optimization
Hook code walkthrough with security notes
Setup and deployment instructions
Risk disclosures (oracle dependency, smart contract risks)


Demo Strategy (≤3 minutes)
Opening (15 seconds)
"LPs on Uniswap face three critical problems: impermanent loss from poorly positioned ranges, MEV attacks on liquidity operations, and privacy leakage when positions are visible. PrivBatch solves all three using Uniswap v4's hooks and intelligent batching."

Problem Demonstration (30 seconds)
Screen 1: The Pain Points

Show solo LP adding liquidity:

Transaction visible in mempool → gets front-run
Wide range → high impermanent loss (show calculation)
Wallet address + position size fully public


Display: "Result: 15% IL, $50 MEV loss, complete transparency"


Solution Architecture (30 seconds)
Screen 2: System Overview Diagram

User signs intent (EIP-712 signature) → commits hash onchain
Multiple users → intents aggregate in agent
Agent:

Fetches oracle price/volatility
Calculates optimal ranges (math shown: center ± k*vol)
Builds Merkle tree of batch
Submits via Flashbots (private mempool)


Hook verifies:

Merkle proof ✓
Signatures ✓
Batch rules (min size, pool diversity) ✓


Positions created atomically


Live Demo Flow (60 seconds)
Screen 3: Terminal/Interface Split Screen

Intent Submission (15s)

Show 3 users signing intents with different ranges/amounts
Display commit transactions (3 TxIDs)
IPFS reveal posting


Agent Processing (20s)

Console log: "Collected 3 intents"
Oracle fetch: "Current price: $2,450, Vol: 8.2%"
Optimization: "Optimal range: $2,390-$2,510 (±2.4%)"
Merkle tree built: "Root: 0xabc123..."
"Submitting via Flashbots..."


Onchain Execution (25s)

Transaction broadcast (show TxID)
Hook verification event emitted:

✓ Proof verified
✓ 3 signatures valid
✓ Batch diversity met


Pool state update: "3 positions created anonymously"
Show positions: Individual wallets not linkable to specific ranges




Results Comparison (30 seconds)
Screen 4: Before/After Metrics
Solo Add:

Gas: 180k per transaction × 3 = 540k
MEV exposure: High (visible in mempool)
IL (poor range): 12-15%
Privacy: Full position details public

PrivBatch:

Gas: 320k for batch = ~40% savings
MEV exposure: Minimal (Flashbots + commit-reveal)
IL (optimized): 4-6% (adaptive ranges)
Privacy: Individual amounts/timing obscured

Show actual transaction IDs: "10+ Sepolia TxIDs in repo"

Agentic Intelligence Demo (15 seconds)
Screen 5: Adaptive Learning

Show agent dashboard:

"Batch #1: IL = 8% → widening ranges"
"Batch #2: IL = 5% → parameters adjusted"
"Batch #3: IL = 4% → optimal found"


Highlight: "Agent learns from onchain performance events"


Closing (15 seconds)
Screen 6: Key Differentiators

✓ Agentic: Adaptive range optimization + automated coordination
✓ Privacy: Batching obscures individuals, commit-reveal prevents front-running
✓ Permissionless: Anyone can run filler script (show GitHub link)
✓ Verifiable: Hook enforces cryptographic proofs

"Trust-minimized LP management for v4. Code + TxIDs in repo."

Expected Demo Deliverables
Transaction IDs (10-15 minimum on Sepolia):

Initial pool deployment
CommitContract deployment
Hook deployment
3× Commit transactions (different users)
Batch execution transaction
Hook verification event transaction
2-3× Rebalance batches
1× Failed batch (invalid proof - reverted)
1× Solo add for comparison

GitHub Repository Structure:
privbatch-coordinator/
├── contracts/
│   ├── CommitContract.sol
│   ├── PrivBatchHook.sol
│   └── test/
├── agent/
│   ├── collector.py (intent API)
│   ├── optimizer.py (range math)
│   ├── executor.py (batching + Flashbots)
│   └── adaptive.py (learning logic)
├── docs/
│   ├── architecture.png (Mermaid diagram)
│   ├── IL-math.md (optimization formulas)
│   └── SECURITY.md (risk disclosures)
├── demo/
│   └── simulation-results.csv
└── README.md (setup + TxIDs)
Video Assets:

Screen recording with voiceover
Transaction explorer split screen
Metrics comparison graphics
Architecture diagram animation


Agentic Components to Emphasize

Adaptive Optimization: Agent adjusts range parameters based on historical IL (onchain feedback loop)
Intelligent Coordination: Batches intents, routes across pools, optimizes execution timing
Oracle Integration: Real-time price/volatility feeds inform decisions
Permissionless Execution: Open-source filler script anyone can run
Performance Tracking: Agent monitors its own success and evolves


Privacy Components to Emphasize

Commit-Reveal: User intent hidden until committed onchain
Batch Obfuscation: Individual positions aggregated, hiding wallet→amount mapping
Merkle Proofs: Verification without revealing full intent set
Flashbots: Private mempool prevents sandwich attacks
IPFS Transparency: Public verifiability post-execution without pre-exposure


This plan delivers a credible, differentiated hackathon project that solves real LP problems using v4's capabilities, with clear agentic intelligence and privacy preservation mechanisms that go beyond simple relaying.